<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Partner Voice Session</title>
    <style>
      :root { --bg:#0b0c10; --fg:#e5e7eb; --muted:#94a3b8; --accent:#22d3ee; --card:#111827; }
      body { margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
      header { padding:16px 20px; border-bottom:1px solid #1f2937; display:flex; align-items:center; gap:12px; }
      header h1 { font-size:18px; margin:0; letter-spacing:.2px; }
      main { padding:16px 20px; display:grid; gap:16px; grid-template-columns: 1fr; }
      .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
      .card { background:var(--card); border:1px solid #1f2937; border-radius:10px; padding:12px; }
      .controls button { background:#0ea5e9; color:white; border:none; padding:10px 14px; border-radius:8px; cursor:pointer; }
      .controls button.secondary { background:#374151; }
      .controls button.danger { background:#ef4444; }
      .controls button:disabled { opacity:.5; cursor:not-allowed; }
      label { color:var(--muted); font-size:12px; display:block; margin-bottom:4px; }
      input, select { background:#0b1220; color:var(--fg); border:1px solid #1f2937; border-radius:8px; padding:8px; }
      textarea { width:100%; min-height:180px; background:#0b1220; color:var(--fg); border:1px solid #1f2937; border-radius:8px; padding:10px; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; }
      .mono { font-family:ui-monospace, SFMono-Regular, Menlo, monospace; }
      .pill { font-size:12px; color:#0ea5e9; background:#062c3b; border:1px solid #0ea5e9; padding:3px 8px; border-radius:999px; }
      .hint { color:var(--muted); font-size:12px; }
      footer { padding:12px 20px; color:#94a3b8; font-size:12px; border-top:1px solid #1f2937; }
    </style>
  </head>
  <body>
    <header>
      <h1>Partner Voice Session</h1>
      <span class="pill" id="supportStatus">Checking speech support…</span>
    </header>
    <main>
      <section class="card">
        <div class="row">
          <div>
            <label>Voice</label>
            <select id="voice"></select>
          </div>
          <div>
            <label>Rate</label>
            <input id="rate" type="number" min="0.5" max="2" step="0.1" value="1.0" />
          </div>
          <div>
            <label>Interval (sec)</label>
            <input id="interval" type="number" min="10" step="5" value="60" />
          </div>
          <div>
            <label>Minutes</label>
            <input id="minutes" type="number" min="1" step="1" value="15" />
          </div>
          <div>
            <label>Readback</label>
            <select id="readback">
              <option value="confirm">Confirm only</option>
              <option value="full">Read full input</option>
              <option value="off">Silent</option>
            </select>
          </div>
        </div>
        <div class="row controls" style="margin-top:10px;">
          <button id="startSession">Start Session</button>
          <button id="stopSession" class="secondary" disabled>Stop Session</button>
          <button id="micToggle" class="secondary">Start Mic</button>
          <button id="readTranscript" class="secondary">Read Transcript</button>
          <button id="saveBtn" class="secondary">Save</button>
          <button id="clearBtn" class="danger">Clear</button>
        </div>
        <div class="row" style="margin-top:6px; align-items:center; gap:12px;">
          <span class="hint">Commands: /pause /resume /skip /read /undo /save /done（日本語もOK: 終了, ポーズ, 再開, 読み上げ, 取り消し, 保存）</span>
          <label style="margin-left:auto; display:flex; gap:6px; align-items:center;">
            <input type="checkbox" id="engage" checked> Partner responses
          </label>
          <label style="display:flex; gap:6px; align-items:center;">
            Tone
            <select id="tone">
              <option value="gentle">Gentle</option>
              <option value="probe">Probe</option>
              <option value="energy">Energy</option>
            </select>
          </label>
        </div>
      </section>

      <section class="card">
        <div class="row">
          <div style="flex:1 1 100%">
            <label for="typed">Type here (Ctrl/Cmd+Enter to add, Enter×2 also OK)</label>
            <textarea id="typed" class="mono" placeholder="あなたの言葉を流し込んでください…" style="height: 220px; font-size: 15px;"></textarea>
            <div class="hint" style="margin-top:6px;">Space: toggle mic · Ctrl/Cmd+Enter: add · Enter×2: add · Esc: stop session · フォーカスは保持されます</div>
          </div>
        </div>
        <div class="row" style="margin-top:10px; align-items: center;">
          <label>Auto-chunk (sec, 0=off)</label>
          <input id="autochunk" type="number" min="0" step="1" value="0" />
          <label class="hint">タイピングが止まってから自動追加</label>
          <label style="margin-left:auto; display:flex; gap:8px; align-items:center;"><input type="checkbox" id="bigInput"> Big Input</label>
        </div>
      </section>

      <section class="card">
        <label>Transcript</label>
        <textarea id="log" readonly></textarea>
      </section>
    </main>
    <footer>
      Built on Web Speech API (voice) + webkitSpeechRecognition (voice input; Chrome). If STT is unsupported, you can still type.
    </footer>

    <script>
      const $ = (s) => document.querySelector(s);
      const state = {
        speaking: false,
        reco: null,
        recoActive: false,
        sessionTimer: null,
        sessionEndsAt: 0,
        nextTick: 0,
        lines: [],
        audioCtx: null,
      };

      // Short chime via WebAudio
      function chime() {
        try {
          if (!state.audioCtx) state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const o = state.audioCtx.createOscillator();
          const g = state.audioCtx.createGain();
          o.type = 'sine';
          o.frequency.value = 880;
          g.gain.setValueAtTime(0.0001, state.audioCtx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.2, state.audioCtx.currentTime + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, state.audioCtx.currentTime + 0.2);
          o.connect(g).connect(state.audioCtx.destination);
          o.start();
          o.stop(state.audioCtx.currentTime + 0.21);
        } catch {}
      }

      // TTS
      function speak(text) {
        if (!('speechSynthesis' in window)) return;
        const u = new SpeechSynthesisUtterance(text);
        const voiceSel = $('#voice').value;
        const rate = parseFloat($('#rate').value || '1.0');
        u.rate = Math.max(0.5, Math.min(2, rate));
        const vs = speechSynthesis.getVoices();
        const v = vs.find(v => v.name === voiceSel);
        if (v) u.voice = v;
        state.speaking = true;
        u.onend = () => { state.speaking = false; };
        speechSynthesis.speak(u);
      }

      function supportCheck() {
        const tts = 'speechSynthesis' in window;
        const stt = 'webkitSpeechRecognition' in window;
        $('#supportStatus').textContent = `${tts ? 'TTS OK' : 'TTS NG'} · ${stt ? 'STT OK' : 'STT NG'}`;
      }

      function populateVoices() {
        if (!('speechSynthesis' in window)) return;
        const sel = $('#voice');
        sel.innerHTML = '';
        const voices = speechSynthesis.getVoices();
        for (const v of voices) {
          if (!v.lang.startsWith('ja') && !v.lang.startsWith('en')) continue;
          const opt = document.createElement('option');
          opt.value = v.name; opt.textContent = `${v.name} (${v.lang})`;
          sel.appendChild(opt);
        }
        // Try to pick a Japanese voice if available
        const ja = voices.find(v => v.lang.startsWith('ja'));
        if (ja) sel.value = ja.name;
      }

      // STT
      function startReco() {
        if (!('webkitSpeechRecognition' in window)) { alert('STT unsupported in this browser.'); return; }
        if (state.recoActive) return;
        const R = new webkitSpeechRecognition();
        R.lang = ($('#voice').value.includes('(') ? ($('#voice').value.match(/\((.*?)\)/)?.[1]||'ja-JP') : 'ja-JP');
        R.interimResults = false; R.continuous = false;
        R.onresult = (e) => {
          const text = e.results[0][0].transcript.trim();
          handleInput(text, /*viaVoice=*/true);
        };
        R.onend = () => { state.recoActive = false; $('#micToggle').textContent = 'Start Mic'; };
        R.onerror = () => { state.recoActive = false; $('#micToggle').textContent = 'Start Mic'; };
        state.reco = R; state.recoActive = true; R.start();
        $('#micToggle').textContent = 'Stop Mic';
      }
      function stopReco() { if (state.reco && state.recoActive) { try { state.reco.stop(); } catch {} } }

      function downloadText(filename, text) {
        const blob = new Blob([text], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename; a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }

      function nowIso() { return new Date().toISOString().slice(0,19).replace('T',' '); }
      function appendLine(text) {
        const stamped = `[${nowIso()}] ${text}`;
        state.lines.push(stamped);
        const log = $('#log');
        log.value += (log.value ? '\n' : '') + stamped;
        log.scrollTop = log.scrollHeight;
      }

      // Natural language command mapping (ja/en)
      function normalizeCommand(text) {
        const t = text.trim().toLowerCase();
        const map = [
          ['done', ['done','/done','end','finish','終了','終わり','ストップ','やめる']],
          ['pause', ['pause','/pause','一時停止','ポーズ','停止']],
          ['resume', ['resume','/resume','再開','続ける','リジューム']],
          ['read', ['read','/read','読み上げ','リード','読んで']],
          ['undo', ['undo','/undo','取り消し','取り消す','アンドゥ']],
          ['save', ['save','/save','保存','セーブ']],
          ['skip', ['skip','/skip','スキップ']]
        ];
        for (const [name, keys] of map) {
          if (keys.some(k => t.startsWith(k))) return {name, arg: t.split(/\s+/).slice(1).join(' ')};
        }
        if (t.startsWith('/')) return {name:'unknown'};
        return null;
      }

      function handleCommand(cmd) {
        switch (cmd.name) {
          case 'pause': stopSessionTimer(); speak('一時停止します。'); return true;
          case 'resume': startSessionTimer(); speak('再開します。'); return true;
          case 'skip': nextPromptSoon(); chime(); return true;
          case 'read': speak($('#log').value || 'まだ何もありません。'); return true;
          case 'undo': {
            if (state.lines.length) { state.lines.pop(); const v=$('#log').value.split(/\n/); v.pop(); $('#log').value=v.join('\n'); speak('取り消しました。'); }
            else { speak('取り消すものはありません。'); }
            return true;
          }
          case 'save': {
            const name = cmd.arg || `session-${Date.now()}.txt`;
            downloadText(name, $('#log').value);
            speak('保存しました。');
            return true;
          }
          case 'done': stopSession(); speak('終了します。お疲れさまでした。'); return true;
          default: speak('使えるコマンドは、ポーズ、再開、スキップ、読み上げ、取り消し、保存、終了です。'); return true;
        }
      }

      function partnerResponse(text) {
        const t = $('#tone').value || 'gentle';
        if (t === 'probe') {
          const probes = ['もう少し詳しく。','いまの核心は？','一言で言うと？'];
          return probes[Math.floor(Math.random()*probes.length)];
        }
        if (t === 'energy') {
          const energ = ['いいね、続けよう。','その勢いで。','次の一歩は？'];
          return energ[Math.floor(Math.random()*energ.length)];
        }
        const gentle = ['受け取りました。','そのまま、どうぞ。','うん。'];
        return gentle[Math.floor(Math.random()*gentle.length)];
      }

      function handleInput(text, viaVoice=false) {
        if (!text) return;
        const cmd = normalizeCommand(text);
        if (cmd) { handleCommand(cmd); return; }
        appendLine(text);
        const mode = $('#readback').value;
        if ($('#engage').checked) {
          const reply = partnerResponse(text);
          if (mode === 'confirm') speak(reply);
          else if (mode === 'full') speak(text + '。' + reply);
        } else {
          if (mode === 'confirm') speak('受け取りました。');
          else if (mode === 'full') speak(text);
        }
        if (viaVoice) chime();
      }

      const PROMPTS = {
        gentle: [
          'そのまま、いま気づいていることをどうぞ。',
          'ゆっくりで大丈夫。言葉にできる範囲で。',
          '呼吸に戻りつつ、続けて。',
        ],
        probe: [
          'いま一番強い感情は？',
          'それはなぜ大事？',
          '一言で要するなら？',
        ],
        energy: [
          'いい流れ。次の一手は？',
          '勢いを保って、短く一文で。',
          'もう一段、踏み込んでみよう。',
        ],
      };

      function nextPromptText() {
        const t = $('#tone').value || 'gentle';
        const arr = PROMPTS[t] || PROMPTS.gentle;
        return arr[Math.floor(Math.random()*arr.length)];
      }

      function startSessionTimer() {
        stopSessionTimer();
        const seconds = parseInt($('#interval').value || '60', 10);
        const speakPrompt = () => { chime(); speak(nextPromptText()); };
        // schedule
        state.sessionTimer = setInterval(speakPrompt, Math.max(10, seconds) * 1000);
      }

      function stopSessionTimer() { if (state.sessionTimer) { clearInterval(state.sessionTimer); state.sessionTimer = null; } }
      function nextPromptSoon() { stopSessionTimer(); state.sessionTimer = setInterval(() => { chime(); speak('続けましょう。'); stopSessionTimer(); startSessionTimer(); }, 1500); }

      function startSession() {
        const mins = parseInt($('#minutes').value || '15', 10);
        state.sessionEndsAt = Date.now() + Math.max(1, mins) * 60 * 1000;
        $('#startSession').disabled = true; $('#stopSession').disabled = false;
        chime(); speak('セッションを開始します。'); startSessionTimer();
        // end watch
        const endWatch = setInterval(() => {
          if (Date.now() >= state.sessionEndsAt) { clearInterval(endWatch); stopSession(); speak('セッションを終了します。'); }
        }, 1000);
      }
      function stopSession() {
        stopSessionTimer(); $('#startSession').disabled = false; $('#stopSession').disabled = true;
      }

      function submitTyped() {
        const el = $('#typed');
        const v = (el.value||'').trim();
        if (!v) return;
        el.value = '';
        handleInput(v, false);
        el.focus();
      }

      let lastTypeTs = 0;
      let autoChunkTimer = null;

      function setupAutoChunk() {
        if (autoChunkTimer) { clearInterval(autoChunkTimer); autoChunkTimer = null; }
        const sec = parseInt($('#autochunk').value||'0',10);
        if (!sec) return;
        autoChunkTimer = setInterval(() => {
          const idle = (Date.now() - lastTypeTs) / 1000;
          if (idle >= sec) submitTyped();
        }, 500);
      }

      // UI bindings
      window.addEventListener('load', () => {
        supportCheck(); populateVoices();
        if ('speechSynthesis' in window) speechSynthesis.onvoiceschanged = populateVoices;
        $('#startSession').addEventListener('click', startSession);
        $('#stopSession').addEventListener('click', stopSession);
        $('#micToggle').addEventListener('click', () => state.recoActive ? stopReco() : startReco());
        $('#readTranscript').addEventListener('click', () => speak($('#log').value || 'まだ何もありません。'));
        $('#saveBtn').addEventListener('click', () => downloadText(`session-${Date.now()}.txt`, $('#log').value));
        $('#clearBtn').addEventListener('click', () => { state.lines=[]; $('#log').value=''; });
        $('#typed').addEventListener('keydown', (e) => {
          if ((e.key === 'Enter') && (e.ctrlKey || e.metaKey)) { e.preventDefault(); submitTyped(); return; }
          if (e.key === 'Enter') {
            const el = e.target; const val = el.value;
            const last2 = val.endsWith('\n\n');
            if (last2) { e.preventDefault(); submitTyped(); return; }
          }
          if (e.key === ' ') { if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return; e.preventDefault(); state.recoActive ? stopReco() : startReco(); }
          if (e.key === 'Escape') { stopSession(); }
        });
        $('#typed').addEventListener('input', () => { lastTypeTs = Date.now(); });
        $('#autochunk').addEventListener('change', setupAutoChunk);
        $('#bigInput').addEventListener('change', (e) => {
          $('#typed').style.height = e.target.checked ? '60vh' : '220px';
          $('#typed').focus();
        });
        setupAutoChunk();
        $('#typed').focus();
      });
    </script>
  </body>
  </html>
